const K = [
  "/_app/immutable/start-5fffc366.js",
  "/_app/immutable/components/pages/_layout.svelte-15023f01.js",
  "/_app/immutable/assets/+layout-5a44d604.css",
  "/_app/immutable/components/error.svelte-7bc58111.js",
  "/_app/immutable/components/pages/(page)/_layout.svelte-b00f644a.js",
  "/_app/immutable/components/pages/(page)/_page.svelte-4fddd7b1.js",
  "/_app/immutable/assets/+page-352bac7e.css",
  "/_app/immutable/components/pages/(page)/_...slug_/_page.svelte-5dce05ec.js",
  "/_app/immutable/components/pages/play/_page.svelte-395e54d8.js",
  "/_app/immutable/chunks/singletons-7037dab1.js",
  "/_app/immutable/chunks/index-4f26f8ba.js",
  "/_app/immutable/chunks/index-6634cca6.js",
  "/_app/immutable/chunks/LinkCopied-fff47d77.js",
  "/_app/immutable/assets/LinkCopied-53ae24f9.css",
  "/_app/immutable/chunks/Game-2cabc409.js",
  "/_app/immutable/chunks/stores-e1794a0a.js",
  "/_app/immutable/chunks/navigation-d91a7844.js",
  "/_app/immutable/chunks/0-164c7e79.js",
  "/_app/immutable/chunks/1-628f1e27.js",
  "/_app/immutable/chunks/2-815eedb9.js",
  "/_app/immutable/chunks/3-627e073b.js",
  "/_app/immutable/chunks/4-05687545.js",
  "/_app/immutable/chunks/5-61f6040e.js"
], V = [
  "/.nojekyll",
  "/CNAME",
  "/apple-touch-icon.png",
  "/browserconfig.xml",
  "/cards/2_clubs.svg",
  "/cards/2_diamonds.svg",
  "/cards/2_hearts.svg",
  "/cards/2_spades.svg",
  "/cards/3_clubs.svg",
  "/cards/3_diamonds.svg",
  "/cards/3_hearts.svg",
  "/cards/3_spades.svg",
  "/cards/4_clubs.svg",
  "/cards/4_diamonds.svg",
  "/cards/4_hearts.svg",
  "/cards/4_spades.svg",
  "/cards/5_clubs.svg",
  "/cards/5_diamonds.svg",
  "/cards/5_hearts.svg",
  "/cards/5_spades.svg",
  "/cards/6_clubs.svg",
  "/cards/6_diamonds.svg",
  "/cards/6_hearts.svg",
  "/cards/6_spades.svg",
  "/cards/7_clubs.svg",
  "/cards/7_diamonds.svg",
  "/cards/7_hearts.svg",
  "/cards/7_spades.svg",
  "/cards/8_clubs.svg",
  "/cards/8_diamonds.svg",
  "/cards/8_hearts.svg",
  "/cards/8_spades.svg",
  "/cards/9_clubs.svg",
  "/cards/9_diamonds.svg",
  "/cards/9_hearts.svg",
  "/cards/9_spades.svg",
  "/cards/A_clubs.svg",
  "/cards/A_diamonds.svg",
  "/cards/A_hearts.svg",
  "/cards/A_spades.svg",
  "/cards/J_clubs.svg",
  "/cards/J_diamonds.svg",
  "/cards/J_hearts.svg",
  "/cards/J_spades.svg",
  "/cards/K_clubs.svg",
  "/cards/K_diamonds.svg",
  "/cards/K_hearts.svg",
  "/cards/K_spades.svg",
  "/cards/Q_clubs.svg",
  "/cards/Q_diamonds.svg",
  "/cards/Q_hearts.svg",
  "/cards/Q_spades.svg",
  "/cards/T_clubs.svg",
  "/cards/T_diamonds.svg",
  "/cards/T_hearts.svg",
  "/cards/T_spades.svg",
  "/cards/_back.svg",
  "/cards/_empty.svg",
  "/cards/_joker_black.svg",
  "/cards/_joker_red.svg",
  "/cards/small/2_clubs.svg",
  "/cards/small/2_diamonds.svg",
  "/cards/small/2_hearts.svg",
  "/cards/small/2_spades.svg",
  "/cards/small/3_clubs.svg",
  "/cards/small/3_diamonds.svg",
  "/cards/small/3_hearts.svg",
  "/cards/small/3_spades.svg",
  "/cards/small/4_clubs.svg",
  "/cards/small/4_diamonds.svg",
  "/cards/small/4_hearts.svg",
  "/cards/small/4_spades.svg",
  "/cards/small/5_clubs.svg",
  "/cards/small/5_diamonds.svg",
  "/cards/small/5_hearts.svg",
  "/cards/small/5_spades.svg",
  "/cards/small/6_clubs.svg",
  "/cards/small/6_diamonds.svg",
  "/cards/small/6_hearts.svg",
  "/cards/small/6_spades.svg",
  "/cards/small/7_clubs.svg",
  "/cards/small/7_diamonds.svg",
  "/cards/small/7_hearts.svg",
  "/cards/small/7_spades.svg",
  "/cards/small/8_clubs.svg",
  "/cards/small/8_diamonds.svg",
  "/cards/small/8_hearts.svg",
  "/cards/small/8_spades.svg",
  "/cards/small/9_clubs.svg",
  "/cards/small/9_diamonds.svg",
  "/cards/small/9_hearts.svg",
  "/cards/small/9_spades.svg",
  "/cards/small/A_clubs.svg",
  "/cards/small/A_diamonds.svg",
  "/cards/small/A_hearts.svg",
  "/cards/small/A_spades.svg",
  "/cards/small/J_clubs.svg",
  "/cards/small/J_diamonds.svg",
  "/cards/small/J_hearts.svg",
  "/cards/small/J_spades.svg",
  "/cards/small/K_clubs.svg",
  "/cards/small/K_diamonds.svg",
  "/cards/small/K_hearts.svg",
  "/cards/small/K_spades.svg",
  "/cards/small/Q_clubs.svg",
  "/cards/small/Q_diamonds.svg",
  "/cards/small/Q_hearts.svg",
  "/cards/small/Q_spades.svg",
  "/cards/small/T_clubs.svg",
  "/cards/small/T_diamonds.svg",
  "/cards/small/T_hearts.svg",
  "/cards/small/T_spades.svg",
  "/cards/small/_back.svg",
  "/cards/small/_empty.svg",
  "/cards/small/_joker_black.svg",
  "/cards/small/_joker_red.svg",
  "/favicon-16x16.png",
  "/favicon-32x32.png",
  "/favicon.ico",
  "/favicon.svg",
  "/manifest.json",
  "/mstile-144x144.png",
  "/mstile-150x150.png",
  "/mstile-310x150.png",
  "/mstile-310x310.png",
  "/mstile-70x70.png",
  "/pwa-192x192.png",
  "/pwa-512x512.png",
  "/safari-pinned-tab.svg"
], A = [
  "/",
  "/play",
  "/about",
  "/about/__data.json"
], j = "1662200593226";
try {
  self["workbox:core:6.5.3"] && _();
} catch {
}
const q = {
  "invalid-value": ({ paramName: t, validValueDescription: e, value: s }) => {
    if (!t || !e)
      throw new Error("Unexpected input to 'invalid-value' error.");
    return `The '${t}' parameter was given a value with an unexpected value. ${e} Received a value of ${JSON.stringify(s)}.`;
  },
  "not-an-array": ({ moduleName: t, className: e, funcName: s, paramName: r }) => {
    if (!t || !e || !s || !r)
      throw new Error("Unexpected input to 'not-an-array' error.");
    return `The parameter '${r}' passed into '${t}.${e}.${s}()' must be an array.`;
  },
  "incorrect-type": ({ expectedType: t, paramName: e, moduleName: s, className: r, funcName: a }) => {
    if (!t || !e || !s || !a)
      throw new Error("Unexpected input to 'incorrect-type' error.");
    const n = r ? `${r}.` : "";
    return `The parameter '${e}' passed into '${s}.${n}${a}()' must be of type ${t}.`;
  },
  "incorrect-class": ({ expectedClassName: t, paramName: e, moduleName: s, className: r, funcName: a, isReturnValueProblem: n }) => {
    if (!t || !s || !a)
      throw new Error("Unexpected input to 'incorrect-class' error.");
    const o = r ? `${r}.` : "";
    return n ? `The return value from '${s}.${o}${a}()' must be an instance of class ${t}.` : `The parameter '${e}' passed into '${s}.${o}${a}()' must be an instance of class ${t}.`;
  },
  "missing-a-method": ({ expectedMethod: t, paramName: e, moduleName: s, className: r, funcName: a }) => {
    if (!t || !e || !s || !r || !a)
      throw new Error("Unexpected input to 'missing-a-method' error.");
    return `${s}.${r}.${a}() expected the '${e}' parameter to expose a '${t}' method.`;
  },
  "add-to-cache-list-unexpected-type": ({ entry: t }) => `An unexpected entry was passed to 'workbox-precaching.PrecacheController.addToCacheList()' The entry '${JSON.stringify(t)}' isn't supported. You must supply an array of strings with one or more characters, objects with a url property or Request objects.`,
  "add-to-cache-list-conflicting-entries": ({ firstEntry: t, secondEntry: e }) => {
    if (!t || !e)
      throw new Error("Unexpected input to 'add-to-cache-list-duplicate-entries' error.");
    return `Two of the entries passed to 'workbox-precaching.PrecacheController.addToCacheList()' had the URL ${t} but different revision details. Workbox is unable to cache and version the asset correctly. Please remove one of the entries.`;
  },
  "plugin-error-request-will-fetch": ({ thrownErrorMessage: t }) => {
    if (!t)
      throw new Error("Unexpected input to 'plugin-error-request-will-fetch', error.");
    return `An error was thrown by a plugins 'requestWillFetch()' method. The thrown error message was: '${t}'.`;
  },
  "invalid-cache-name": ({ cacheNameId: t, value: e }) => {
    if (!t)
      throw new Error("Expected a 'cacheNameId' for error 'invalid-cache-name'");
    return `You must provide a name containing at least one character for setCacheDetails({${t}: '...'}). Received a value of '${JSON.stringify(e)}'`;
  },
  "unregister-route-but-not-found-with-method": ({ method: t }) => {
    if (!t)
      throw new Error("Unexpected input to 'unregister-route-but-not-found-with-method' error.");
    return `The route you're trying to unregister was not  previously registered for the method type '${t}'.`;
  },
  "unregister-route-route-not-registered": () => "The route you're trying to unregister was not previously registered.",
  "queue-replay-failed": ({ name: t }) => `Replaying the background sync queue '${t}' failed.`,
  "duplicate-queue-name": ({ name: t }) => `The Queue name '${t}' is already being used. All instances of backgroundSync.Queue must be given unique names.`,
  "expired-test-without-max-age": ({ methodName: t, paramName: e }) => `The '${t}()' method can only be used when the '${e}' is used in the constructor.`,
  "unsupported-route-type": ({ moduleName: t, className: e, funcName: s, paramName: r }) => `The supplied '${r}' parameter was an unsupported type. Please check the docs for ${t}.${e}.${s} for valid input types.`,
  "not-array-of-class": ({ value: t, expectedClass: e, moduleName: s, className: r, funcName: a, paramName: n }) => `The supplied '${n}' parameter must be an array of '${e}' objects. Received '${JSON.stringify(t)},'. Please check the call to ${s}.${r}.${a}() to fix the issue.`,
  "max-entries-or-age-required": ({ moduleName: t, className: e, funcName: s }) => `You must define either config.maxEntries or config.maxAgeSecondsin ${t}.${e}.${s}`,
  "statuses-or-headers-required": ({ moduleName: t, className: e, funcName: s }) => `You must define either config.statuses or config.headersin ${t}.${e}.${s}`,
  "invalid-string": ({ moduleName: t, funcName: e, paramName: s }) => {
    if (!s || !t || !e)
      throw new Error("Unexpected input to 'invalid-string' error.");
    return `When using strings, the '${s}' parameter must start with 'http' (for cross-origin matches) or '/' (for same-origin matches). Please see the docs for ${t}.${e}() for more info.`;
  },
  "channel-name-required": () => "You must provide a channelName to construct a BroadcastCacheUpdate instance.",
  "invalid-responses-are-same-args": () => "The arguments passed into responsesAreSame() appear to be invalid. Please ensure valid Responses are used.",
  "expire-custom-caches-only": () => "You must provide a 'cacheName' property when using the expiration plugin with a runtime caching strategy.",
  "unit-must-be-bytes": ({ normalizedRangeHeader: t }) => {
    if (!t)
      throw new Error("Unexpected input to 'unit-must-be-bytes' error.");
    return `The 'unit' portion of the Range header must be set to 'bytes'. The Range header provided was "${t}"`;
  },
  "single-range-only": ({ normalizedRangeHeader: t }) => {
    if (!t)
      throw new Error("Unexpected input to 'single-range-only' error.");
    return `Multiple ranges are not supported. Please use a  single start value, and optional end value. The Range header provided was "${t}"`;
  },
  "invalid-range-values": ({ normalizedRangeHeader: t }) => {
    if (!t)
      throw new Error("Unexpected input to 'invalid-range-values' error.");
    return `The Range header is missing both start and end values. At least one of those values is needed. The Range header provided was "${t}"`;
  },
  "no-range-header": () => "No Range header was found in the Request provided.",
  "range-not-satisfiable": ({ size: t, start: e, end: s }) => `The start (${e}) and end (${s}) values in the Range are not satisfiable by the cached response, which is ${t} bytes.`,
  "attempt-to-cache-non-get-request": ({ url: t, method: e }) => `Unable to cache '${t}' because it is a '${e}' request and only 'GET' requests can be cached.`,
  "cache-put-with-no-response": ({ url: t }) => `There was an attempt to cache '${t}' but the response was not defined.`,
  "no-response": ({ url: t, error: e }) => {
    let s = `The strategy could not generate a response for '${t}'.`;
    return e && (s += ` The underlying error is ${e}.`), s;
  },
  "bad-precaching-response": ({ url: t, status: e }) => `The precaching request for '${t}' failed` + (e ? ` with an HTTP status of ${e}.` : "."),
  "non-precached-url": ({ url: t }) => `createHandlerBoundToURL('${t}') was called, but that URL is not precached. Please pass in a URL that is precached instead.`,
  "add-to-cache-list-conflicting-integrities": ({ url: t }) => `Two of the entries passed to 'workbox-precaching.PrecacheController.addToCacheList()' had the URL ${t} with different integrity values. Please remove one of them.`,
  "missing-precache-entry": ({ cacheName: t, url: e }) => `Unable to find a precached response in ${t} for ${e}.`,
  "cross-origin-copy-response": ({ origin: t }) => `workbox-core.copyResponse() can only be used with same-origin responses. It was passed a response with origin ${t}.`,
  "opaque-streams-source": ({ type: t }) => {
    const e = `One of the workbox-streams sources resulted in an '${t}' response.`;
    return t === "opaqueredirect" ? `${e} Please do not use a navigation request that results in a redirect as a source.` : `${e} Please ensure your sources are CORS-enabled.`;
  }
}, S = (t, ...e) => {
  let s = t;
  return e.length > 0 && (s += ` :: ${JSON.stringify(e)}`), s;
}, I = (t, e = {}) => {
  const s = q[t];
  if (!s)
    throw new Error(`Unable to find message for code '${t}'.`);
  return s(e);
}, W = "production" === "production" ? S : I;
class u extends Error {
  constructor(e, s) {
    const r = W(e, s);
    super(r), this.name = e, this.details = s;
  }
}
const M = (t, e) => {
  if (!Array.isArray(t))
    throw new u("not-an-array", e);
}, F = (t, e, s) => {
  if (typeof t[e] !== "function")
    throw s.expectedMethod = e, new u("missing-a-method", s);
}, H = (t, e, s) => {
  if (typeof t !== e)
    throw s.expectedType = e, new u("incorrect-type", s);
}, B = (t, e, s) => {
  if (!(t instanceof e))
    throw s.expectedClassName = e.name, new u("incorrect-class", s);
}, G = (t, e, s) => {
  if (!e.includes(t))
    throw s.validValueDescription = `Valid values are ${JSON.stringify(e)}.`, new u("invalid-value", s);
}, J = (t, e, s) => {
  const r = new u("not-array-of-class", s);
  if (!Array.isArray(t))
    throw r;
  for (const a of t)
    if (!(a instanceof e))
      throw r;
}, d = "production" === "production" ? null : {
  hasMethod: F,
  isArray: M,
  isInstance: B,
  isOneOf: G,
  isType: H,
  isArrayOfClass: J
}, g = {
  googleAnalytics: "googleAnalytics",
  precache: "precache-v2",
  prefix: "workbox",
  runtime: "runtime",
  suffix: typeof registration < "u" ? registration.scope : ""
}, C = (t) => [g.prefix, t, g.suffix].filter((e) => e && e.length > 0).join("-"), Q = (t) => {
  for (const e of Object.keys(g))
    t(e);
}, k = {
  updateDetails: (t) => {
    Q((e) => {
      typeof t[e] == "string" && (g[e] = t[e]);
    });
  },
  getGoogleAnalyticsName: (t) => t || C(g.googleAnalytics),
  getPrecacheName: (t) => t || C(g.precache),
  getPrefix: () => g.prefix,
  getRuntimeName: (t) => t || C(g.runtime),
  getSuffix: () => g.suffix
}, i = "production" === "production" ? null : (() => {
  "__WB_DISABLE_DEV_LOGS" in self || (self.__WB_DISABLE_DEV_LOGS = !1);
  let t = !1;
  const e = {
    debug: "#7f8c8d",
    log: "#2ecc71",
    warn: "#f39c12",
    error: "#c0392b",
    groupCollapsed: "#3498db",
    groupEnd: null
  }, s = function(n, o) {
    if (self.__WB_DISABLE_DEV_LOGS)
      return;
    if (n === "groupCollapsed" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      console[n](...o);
      return;
    }
    const c = [
      `background: ${e[n]}`,
      "border-radius: 0.5em",
      "color: white",
      "font-weight: bold",
      "padding: 2px 0.5em"
    ], l = t ? [] : ["%cworkbox", c.join(";")];
    console[n](...l, ...o), n === "groupCollapsed" && (t = !0), n === "groupEnd" && (t = !1);
  }, r = {}, a = Object.keys(e);
  for (const n of a) {
    const o = n;
    r[o] = (...c) => {
      s(o, c);
    };
  }
  return r;
})();
function T(t, e) {
  const s = e();
  return t.waitUntil(s), s;
}
try {
  self["workbox:precaching:6.5.3"] && _();
} catch {
}
const Y = "__WB_REVISION__";
function X(t) {
  if (!t)
    throw new u("add-to-cache-list-unexpected-type", { entry: t });
  if (typeof t == "string") {
    const n = new URL(t, location.href);
    return {
      cacheKey: n.href,
      url: n.href
    };
  }
  const { revision: e, url: s } = t;
  if (!s)
    throw new u("add-to-cache-list-unexpected-type", { entry: t });
  if (!e) {
    const n = new URL(s, location.href);
    return {
      cacheKey: n.href,
      url: n.href
    };
  }
  const r = new URL(s, location.href), a = new URL(s, location.href);
  return r.searchParams.set(Y, e), {
    cacheKey: r.href,
    url: a.href
  };
}
class Z {
  constructor() {
    this.updatedURLs = [], this.notUpdatedURLs = [], this.handlerWillStart = async ({ request: e, state: s }) => {
      s && (s.originalRequest = e);
    }, this.cachedResponseWillBeUsed = async ({ event: e, state: s, cachedResponse: r }) => {
      if (e.type === "install" && s && s.originalRequest && s.originalRequest instanceof Request) {
        const a = s.originalRequest.url;
        r ? this.notUpdatedURLs.push(a) : this.updatedURLs.push(a);
      }
      return r;
    };
  }
}
class z {
  constructor({ precacheController: e }) {
    this.cacheKeyWillBeUsed = async ({ request: s, params: r }) => {
      const a = (r == null ? void 0 : r.cacheKey) || this._precacheController.getCacheKeyForURL(s.url);
      return a ? new Request(a, { headers: s.headers }) : s;
    }, this._precacheController = e;
  }
}
const ee = (t, e) => {
  i.groupCollapsed(t);
  for (const s of e)
    i.log(s);
  i.groupEnd();
};
function se(t) {
  const e = t.length;
  e > 0 && (i.groupCollapsed(`During precaching cleanup, ${e} cached request${e === 1 ? " was" : "s were"} deleted.`), ee("Deleted Cache Requests", t), i.groupEnd());
}
function U(t, e) {
  if (e.length !== 0) {
    i.groupCollapsed(t);
    for (const s of e)
      i.log(s);
    i.groupEnd();
  }
}
function te(t, e) {
  const s = t.length, r = e.length;
  if (s || r) {
    let a = `Precaching ${s} file${s === 1 ? "" : "s"}.`;
    r > 0 && (a += ` ${r} file${r === 1 ? " is" : "s are"} already cached.`), i.groupCollapsed(a), U("View newly precached URLs.", t), U("View previously precached URLs.", e), i.groupEnd();
  }
}
let v;
function re() {
  if (v === void 0) {
    const t = new Response("");
    if ("body" in t)
      try {
        new Response(t.body), v = !0;
      } catch {
        v = !1;
      }
    v = !1;
  }
  return v;
}
async function ae(t, e) {
  let s = null;
  if (t.url && (s = new URL(t.url).origin), s !== self.location.origin)
    throw new u("cross-origin-copy-response", { origin: s });
  const r = t.clone(), a = {
    headers: new Headers(r.headers),
    status: r.status,
    statusText: r.statusText
  }, n = e ? e(a) : a, o = re() ? r.body : await r.blob();
  return new Response(o, n);
}
const h = (t) => new URL(String(t), location.href).href.replace(new RegExp(`^${location.origin}`), "");
function O(t, e) {
  const s = new URL(t);
  for (const r of e)
    s.searchParams.delete(r);
  return s.href;
}
async function ne(t, e, s, r) {
  const a = O(e.url, s);
  if (e.url === a)
    return t.match(e, r);
  const n = Object.assign(Object.assign({}, r), { ignoreSearch: !0 }), o = await t.keys(e, n);
  for (const c of o) {
    const l = O(c.url, s);
    if (a === l)
      return t.match(c, r);
  }
}
class oe {
  constructor() {
    this.promise = new Promise((e, s) => {
      this.resolve = e, this.reject = s;
    });
  }
}
const L = /* @__PURE__ */ new Set();
async function ce() {
  "production" !== "production" && i.log(`About to run ${L.size} callbacks to clean up caches.`);
  for (const t of L)
    await t(), "production" !== "production" && i.log(t, "is complete.");
  "production" !== "production" && i.log("Finished running callbacks.");
}
function ie(t) {
  return new Promise((e) => setTimeout(e, t));
}
try {
  self["workbox:strategies:6.5.3"] && _();
} catch {
}
function E(t) {
  return typeof t == "string" ? new Request(t) : t;
}
class le {
  constructor(e, s) {
    this._cacheKeys = {}, "production" !== "production" && d.isInstance(s.event, ExtendableEvent, {
      moduleName: "workbox-strategies",
      className: "StrategyHandler",
      funcName: "constructor",
      paramName: "options.event"
    }), Object.assign(this, s), this.event = s.event, this._strategy = e, this._handlerDeferred = new oe(), this._extendLifetimePromises = [], this._plugins = [...e.plugins], this._pluginStateMap = /* @__PURE__ */ new Map();
    for (const r of this._plugins)
      this._pluginStateMap.set(r, {});
    this.event.waitUntil(this._handlerDeferred.promise);
  }
  async fetch(e) {
    const { event: s } = this;
    let r = E(e);
    if (r.mode === "navigate" && s instanceof FetchEvent && s.preloadResponse) {
      const o = await s.preloadResponse;
      if (o)
        return "production" !== "production" && i.log(`Using a preloaded navigation response for '${h(r.url)}'`), o;
    }
    const a = this.hasCallback("fetchDidFail") ? r.clone() : null;
    try {
      for (const o of this.iterateCallbacks("requestWillFetch"))
        r = await o({ request: r.clone(), event: s });
    } catch (o) {
      if (o instanceof Error)
        throw new u("plugin-error-request-will-fetch", {
          thrownErrorMessage: o.message
        });
    }
    const n = r.clone();
    try {
      let o;
      o = await fetch(r, r.mode === "navigate" ? void 0 : this._strategy.fetchOptions), "production" !== "production" && i.debug(`Network request for '${h(r.url)}' returned a response with status '${o.status}'.`);
      for (const c of this.iterateCallbacks("fetchDidSucceed"))
        o = await c({
          event: s,
          request: n,
          response: o
        });
      return o;
    } catch (o) {
      throw "production" !== "production" && i.log(`Network request for '${h(r.url)}' threw an error.`, o), a && await this.runCallbacks("fetchDidFail", {
        error: o,
        event: s,
        originalRequest: a.clone(),
        request: n.clone()
      }), o;
    }
  }
  async fetchAndCachePut(e) {
    const s = await this.fetch(e), r = s.clone();
    return this.waitUntil(this.cachePut(e, r)), s;
  }
  async cacheMatch(e) {
    const s = E(e);
    let r;
    const { cacheName: a, matchOptions: n } = this._strategy, o = await this.getCacheKey(s, "read"), c = Object.assign(Object.assign({}, n), { cacheName: a });
    r = await caches.match(o, c), "production" !== "production" && (r ? i.debug(`Found a cached response in '${a}'.`) : i.debug(`No cached response found in '${a}'.`));
    for (const l of this.iterateCallbacks("cachedResponseWillBeUsed"))
      r = await l({
        cacheName: a,
        matchOptions: n,
        cachedResponse: r,
        request: o,
        event: this.event
      }) || void 0;
    return r;
  }
  async cachePut(e, s) {
    const r = E(e);
    await ie(0);
    const a = await this.getCacheKey(r, "write");
    if ("production" !== "production") {
      if (a.method && a.method !== "GET")
        throw new u("attempt-to-cache-non-get-request", {
          url: h(a.url),
          method: a.method
        });
      const p = s.headers.get("Vary");
      p && i.debug(`The response for ${h(a.url)} has a 'Vary: ${p}' header. Consider setting the {ignoreVary: true} option on your strategy to ensure cache matching and deletion works as expected.`);
    }
    if (!s)
      throw "production" !== "production" && i.error(`Cannot cache non-existent response for '${h(a.url)}'.`), new u("cache-put-with-no-response", {
        url: h(a.url)
      });
    const n = await this._ensureResponseSafeToCache(s);
    if (!n)
      return "production" !== "production" && i.debug(`Response '${h(a.url)}' will not be cached.`, n), !1;
    const { cacheName: o, matchOptions: c } = this._strategy, l = await self.caches.open(o), m = this.hasCallback("cacheDidUpdate"), w = m ? await ne(
      l,
      a.clone(),
      ["__WB_REVISION__"],
      c
    ) : null;
    "production" !== "production" && i.debug(`Updating the '${o}' cache with a new Response for ${h(a.url)}.`);
    try {
      await l.put(a, m ? n.clone() : n);
    } catch (p) {
      if (p instanceof Error)
        throw p.name === "QuotaExceededError" && await ce(), p;
    }
    for (const p of this.iterateCallbacks("cacheDidUpdate"))
      await p({
        cacheName: o,
        oldResponse: w,
        newResponse: n.clone(),
        request: a,
        event: this.event
      });
    return !0;
  }
  async getCacheKey(e, s) {
    const r = `${e.url} | ${s}`;
    if (!this._cacheKeys[r]) {
      let a = e;
      for (const n of this.iterateCallbacks("cacheKeyWillBeUsed"))
        a = E(await n({
          mode: s,
          request: a,
          event: this.event,
          params: this.params
        }));
      this._cacheKeys[r] = a;
    }
    return this._cacheKeys[r];
  }
  hasCallback(e) {
    for (const s of this._strategy.plugins)
      if (e in s)
        return !0;
    return !1;
  }
  async runCallbacks(e, s) {
    for (const r of this.iterateCallbacks(e))
      await r(s);
  }
  *iterateCallbacks(e) {
    for (const s of this._strategy.plugins)
      if (typeof s[e] == "function") {
        const r = this._pluginStateMap.get(s);
        yield (n) => {
          const o = Object.assign(Object.assign({}, n), { state: r });
          return s[e](o);
        };
      }
  }
  waitUntil(e) {
    return this._extendLifetimePromises.push(e), e;
  }
  async doneWaiting() {
    let e;
    for (; e = this._extendLifetimePromises.shift(); )
      await e;
  }
  destroy() {
    this._handlerDeferred.resolve(null);
  }
  async _ensureResponseSafeToCache(e) {
    let s = e, r = !1;
    for (const a of this.iterateCallbacks("cacheWillUpdate"))
      if (s = await a({
        request: this.request,
        response: s,
        event: this.event
      }) || void 0, r = !0, !s)
        break;
    return r || (s && s.status !== 200 && (s = void 0), "production" !== "production" && s && s.status !== 200 && (s.status === 0 ? i.warn(`The response for '${this.request.url}' is an opaque response. The caching strategy that you're using will not cache opaque responses by default.`) : i.debug(`The response for '${this.request.url}' returned a status code of '${e.status}' and won't be cached as a result.`))), s;
  }
}
class ue {
  constructor(e = {}) {
    this.cacheName = k.getRuntimeName(e.cacheName), this.plugins = e.plugins || [], this.fetchOptions = e.fetchOptions, this.matchOptions = e.matchOptions;
  }
  handle(e) {
    const [s] = this.handleAll(e);
    return s;
  }
  handleAll(e) {
    e instanceof FetchEvent && (e = {
      event: e,
      request: e.request
    });
    const s = e.event, r = typeof e.request == "string" ? new Request(e.request) : e.request, a = "params" in e ? e.params : void 0, n = new le(this, { event: s, request: r, params: a }), o = this._getResponse(n, r, s), c = this._awaitComplete(o, n, r, s);
    return [o, c];
  }
  async _getResponse(e, s, r) {
    await e.runCallbacks("handlerWillStart", { event: r, request: s });
    let a;
    try {
      if (a = await this._handle(s, e), !a || a.type === "error")
        throw new u("no-response", { url: s.url });
    } catch (n) {
      if (n instanceof Error) {
        for (const o of e.iterateCallbacks("handlerDidError"))
          if (a = await o({ error: n, event: r, request: s }), a)
            break;
      }
      if (a)
        "production" !== "production" && i.log(`While responding to '${h(s.url)}', an ${n instanceof Error ? n.toString() : ""} error occurred. Using a fallback response provided by a handlerDidError plugin.`);
      else
        throw n;
    }
    for (const n of e.iterateCallbacks("handlerWillRespond"))
      a = await n({ event: r, request: s, response: a });
    return a;
  }
  async _awaitComplete(e, s, r, a) {
    let n, o;
    try {
      n = await e;
    } catch {
    }
    try {
      await s.runCallbacks("handlerDidRespond", {
        event: a,
        request: r,
        response: n
      }), await s.doneWaiting();
    } catch (c) {
      c instanceof Error && (o = c);
    }
    if (await s.runCallbacks("handlerDidComplete", {
      event: a,
      request: r,
      response: n,
      error: o
    }), s.destroy(), o)
      throw o;
  }
}
class y extends ue {
  constructor(e = {}) {
    e.cacheName = k.getPrecacheName(e.cacheName), super(e), this._fallbackToNetwork = e.fallbackToNetwork !== !1, this.plugins.push(y.copyRedirectedCacheableResponsesPlugin);
  }
  async _handle(e, s) {
    const r = await s.cacheMatch(e);
    return r || (s.event && s.event.type === "install" ? await this._handleInstall(e, s) : await this._handleFetch(e, s));
  }
  async _handleFetch(e, s) {
    let r;
    const a = s.params || {};
    if (this._fallbackToNetwork) {
      "production" !== "production" && i.warn(`The precached response for ${h(e.url)} in ${this.cacheName} was not found. Falling back to the network.`);
      const n = a.integrity, o = e.integrity, c = !o || o === n;
      if (r = await s.fetch(new Request(e, {
        integrity: e.mode !== "no-cors" ? o || n : void 0
      })), n && c && e.mode !== "no-cors") {
        this._useDefaultCacheabilityPluginIfNeeded();
        const l = await s.cachePut(e, r.clone());
        "production" !== "production" && l && i.log(`A response for ${h(e.url)} was used to "repair" the precache.`);
      }
    } else
      throw new u("missing-precache-entry", {
        cacheName: this.cacheName,
        url: e.url
      });
    if ("production" !== "production") {
      const n = a.cacheKey || await s.getCacheKey(e, "read");
      i.groupCollapsed("Precaching is responding to: " + h(e.url)), i.log(`Serving the precached url: ${h(n instanceof Request ? n.url : n)}`), i.groupCollapsed("View request details here."), i.log(e), i.groupEnd(), i.groupCollapsed("View response details here."), i.log(r), i.groupEnd(), i.groupEnd();
    }
    return r;
  }
  async _handleInstall(e, s) {
    this._useDefaultCacheabilityPluginIfNeeded();
    const r = await s.fetch(e);
    if (!await s.cachePut(e, r.clone()))
      throw new u("bad-precaching-response", {
        url: e.url,
        status: r.status
      });
    return r;
  }
  _useDefaultCacheabilityPluginIfNeeded() {
    let e = null, s = 0;
    for (const [r, a] of this.plugins.entries())
      a !== y.copyRedirectedCacheableResponsesPlugin && (a === y.defaultPrecacheCacheabilityPlugin && (e = r), a.cacheWillUpdate && s++);
    s === 0 ? this.plugins.push(y.defaultPrecacheCacheabilityPlugin) : s > 1 && e !== null && this.plugins.splice(e, 1);
  }
}
y.defaultPrecacheCacheabilityPlugin = {
  async cacheWillUpdate({ response: t }) {
    return !t || t.status >= 400 ? null : t;
  }
};
y.copyRedirectedCacheableResponsesPlugin = {
  async cacheWillUpdate({ response: t }) {
    return t.redirected ? await ae(t) : t;
  }
};
class he {
  constructor({ cacheName: e, plugins: s = [], fallbackToNetwork: r = !0 } = {}) {
    this._urlsToCacheKeys = /* @__PURE__ */ new Map(), this._urlsToCacheModes = /* @__PURE__ */ new Map(), this._cacheKeysToIntegrities = /* @__PURE__ */ new Map(), this._strategy = new y({
      cacheName: k.getPrecacheName(e),
      plugins: [
        ...s,
        new z({ precacheController: this })
      ],
      fallbackToNetwork: r
    }), this.install = this.install.bind(this), this.activate = this.activate.bind(this);
  }
  get strategy() {
    return this._strategy;
  }
  precache(e) {
    this.addToCacheList(e), this._installAndActiveListenersAdded || (self.addEventListener("install", this.install), self.addEventListener("activate", this.activate), this._installAndActiveListenersAdded = !0);
  }
  addToCacheList(e) {
    "production" !== "production" && d.isArray(e, {
      moduleName: "workbox-precaching",
      className: "PrecacheController",
      funcName: "addToCacheList",
      paramName: "entries"
    });
    const s = [];
    for (const r of e) {
      typeof r == "string" ? s.push(r) : r && r.revision === void 0 && s.push(r.url);
      const { cacheKey: a, url: n } = X(r), o = typeof r != "string" && r.revision ? "reload" : "default";
      if (this._urlsToCacheKeys.has(n) && this._urlsToCacheKeys.get(n) !== a)
        throw new u("add-to-cache-list-conflicting-entries", {
          firstEntry: this._urlsToCacheKeys.get(n),
          secondEntry: a
        });
      if (typeof r != "string" && r.integrity) {
        if (this._cacheKeysToIntegrities.has(a) && this._cacheKeysToIntegrities.get(a) !== r.integrity)
          throw new u("add-to-cache-list-conflicting-integrities", {
            url: n
          });
        this._cacheKeysToIntegrities.set(a, r.integrity);
      }
      if (this._urlsToCacheKeys.set(n, a), this._urlsToCacheModes.set(n, o), s.length > 0) {
        const c = `Workbox is precaching URLs without revision info: ${s.join(", ")}
This is generally NOT safe. Learn more at https://bit.ly/wb-precache`;
        "production" === "production" ? console.warn(c) : i.warn(c);
      }
    }
  }
  install(e) {
    return T(e, async () => {
      const s = new Z();
      this.strategy.plugins.push(s);
      for (const [n, o] of this._urlsToCacheKeys) {
        const c = this._cacheKeysToIntegrities.get(o), l = this._urlsToCacheModes.get(n), m = new Request(n, {
          integrity: c,
          cache: l,
          credentials: "same-origin"
        });
        await Promise.all(this.strategy.handleAll({
          params: { cacheKey: o },
          request: m,
          event: e
        }));
      }
      const { updatedURLs: r, notUpdatedURLs: a } = s;
      return "production" !== "production" && te(r, a), { updatedURLs: r, notUpdatedURLs: a };
    });
  }
  activate(e) {
    return T(e, async () => {
      const s = await self.caches.open(this.strategy.cacheName), r = await s.keys(), a = new Set(this._urlsToCacheKeys.values()), n = [];
      for (const o of r)
        a.has(o.url) || (await s.delete(o), n.push(o.url));
      return "production" !== "production" && se(n), { deletedURLs: n };
    });
  }
  getURLsToCacheKeys() {
    return this._urlsToCacheKeys;
  }
  getCachedURLs() {
    return [...this._urlsToCacheKeys.keys()];
  }
  getCacheKeyForURL(e) {
    const s = new URL(e, location.href);
    return this._urlsToCacheKeys.get(s.href);
  }
  getIntegrityForCacheKey(e) {
    return this._cacheKeysToIntegrities.get(e);
  }
  async matchPrecache(e) {
    const s = e instanceof Request ? e.url : e, r = this.getCacheKeyForURL(s);
    if (r)
      return (await self.caches.open(this.strategy.cacheName)).match(r);
  }
  createHandlerBoundToURL(e) {
    const s = this.getCacheKeyForURL(e);
    if (!s)
      throw new u("non-precached-url", { url: e });
    return (r) => (r.request = new Request(e), r.params = Object.assign({ cacheKey: s }, r.params), this.strategy.handle(r));
  }
}
let $;
const D = () => ($ || ($ = new he()), $);
try {
  self["workbox:routing:6.5.3"] && _();
} catch {
}
const P = "GET", de = [
  "DELETE",
  "GET",
  "HEAD",
  "PATCH",
  "POST",
  "PUT"
], N = (t) => t && typeof t == "object" ? ("production" !== "production" && d.hasMethod(t, "handle", {
  moduleName: "workbox-routing",
  className: "Route",
  funcName: "constructor",
  paramName: "handler"
}), t) : ("production" !== "production" && d.isType(t, "function", {
  moduleName: "workbox-routing",
  className: "Route",
  funcName: "constructor",
  paramName: "handler"
}), { handle: t });
class R {
  constructor(e, s, r = P) {
    "production" !== "production" && (d.isType(e, "function", {
      moduleName: "workbox-routing",
      className: "Route",
      funcName: "constructor",
      paramName: "match"
    }), r && d.isOneOf(r, de, { paramName: "method" })), this.handler = N(s), this.match = e, this.method = r;
  }
  setCatchHandler(e) {
    this.catchHandler = N(e);
  }
}
class pe extends R {
  constructor(e, s, r) {
    "production" !== "production" && d.isInstance(e, RegExp, {
      moduleName: "workbox-routing",
      className: "RegExpRoute",
      funcName: "constructor",
      paramName: "pattern"
    });
    const a = ({ url: n }) => {
      const o = e.exec(n.href);
      if (!!o) {
        if (n.origin !== location.origin && o.index !== 0) {
          "production" !== "production" && i.debug(`The regular expression '${e.toString()}' only partially matched against the cross-origin URL '${n.toString()}'. RegExpRoute's will only handle cross-origin requests if they match the entire URL.`);
          return;
        }
        return o.slice(1);
      }
    };
    super(a, s, r);
  }
}
class fe {
  constructor() {
    this._routes = /* @__PURE__ */ new Map(), this._defaultHandlerMap = /* @__PURE__ */ new Map();
  }
  get routes() {
    return this._routes;
  }
  addFetchListener() {
    self.addEventListener("fetch", (e) => {
      const { request: s } = e, r = this.handleRequest({ request: s, event: e });
      r && e.respondWith(r);
    });
  }
  addCacheListener() {
    self.addEventListener("message", (e) => {
      if (e.data && e.data.type === "CACHE_URLS") {
        const { payload: s } = e.data;
        "production" !== "production" && i.debug("Caching URLs from the window", s.urlsToCache);
        const r = Promise.all(s.urlsToCache.map((a) => {
          typeof a == "string" && (a = [a]);
          const n = new Request(...a);
          return this.handleRequest({ request: n, event: e });
        }));
        e.waitUntil(r), e.ports && e.ports[0] && r.then(() => e.ports[0].postMessage(!0));
      }
    });
  }
  handleRequest({ request: e, event: s }) {
    "production" !== "production" && d.isInstance(e, Request, {
      moduleName: "workbox-routing",
      className: "Router",
      funcName: "handleRequest",
      paramName: "options.request"
    });
    const r = new URL(e.url, location.href);
    if (!r.protocol.startsWith("http")) {
      "production" !== "production" && i.debug("Workbox Router only supports URLs that start with 'http'.");
      return;
    }
    const a = r.origin === location.origin, { params: n, route: o } = this.findMatchingRoute({
      event: s,
      request: e,
      sameOrigin: a,
      url: r
    });
    let c = o && o.handler;
    const l = [];
    "production" !== "production" && c && (l.push(["Found a route to handle this request:", o]), n && l.push([
      "Passing the following params to the route's handler:",
      n
    ]));
    const m = e.method;
    if (!c && this._defaultHandlerMap.has(m) && ("production" !== "production" && l.push(`Failed to find a matching route. Falling back to the default handler for ${m}.`), c = this._defaultHandlerMap.get(m)), !c) {
      "production" !== "production" && i.debug(`No route found for: ${h(r)}`);
      return;
    }
    "production" !== "production" && (i.groupCollapsed(`Router is responding to: ${h(r)}`), l.forEach((f) => {
      Array.isArray(f) ? i.log(...f) : i.log(f);
    }), i.groupEnd());
    let w;
    try {
      w = c.handle({ url: r, request: e, event: s, params: n });
    } catch (f) {
      w = Promise.reject(f);
    }
    const p = o && o.catchHandler;
    return w instanceof Promise && (this._catchHandler || p) && (w = w.catch(async (f) => {
      if (p) {
        "production" !== "production" && (i.groupCollapsed(`Error thrown when responding to:  ${h(r)}. Falling back to route's Catch Handler.`), i.error("Error thrown by:", o), i.error(f), i.groupEnd());
        try {
          return await p.handle({ url: r, request: e, event: s, params: n });
        } catch (x) {
          x instanceof Error && (f = x);
        }
      }
      if (this._catchHandler)
        return "production" !== "production" && (i.groupCollapsed(`Error thrown when responding to:  ${h(r)}. Falling back to global Catch Handler.`), i.error("Error thrown by:", o), i.error(f), i.groupEnd()), this._catchHandler.handle({ url: r, request: e, event: s });
      throw f;
    })), w;
  }
  findMatchingRoute({ url: e, sameOrigin: s, request: r, event: a }) {
    const n = this._routes.get(r.method) || [];
    for (const o of n) {
      let c;
      const l = o.match({ url: e, sameOrigin: s, request: r, event: a });
      if (l)
        return "production" !== "production" && l instanceof Promise && i.warn(`While routing ${h(e)}, an async matchCallback function was used. Please convert the following route to use a synchronous matchCallback function:`, o), c = l, (Array.isArray(c) && c.length === 0 || l.constructor === Object && Object.keys(l).length === 0 || typeof l == "boolean") && (c = void 0), { route: o, params: c };
    }
    return {};
  }
  setDefaultHandler(e, s = P) {
    this._defaultHandlerMap.set(s, N(e));
  }
  setCatchHandler(e) {
    this._catchHandler = N(e);
  }
  registerRoute(e) {
    "production" !== "production" && (d.isType(e, "object", {
      moduleName: "workbox-routing",
      className: "Router",
      funcName: "registerRoute",
      paramName: "route"
    }), d.hasMethod(e, "match", {
      moduleName: "workbox-routing",
      className: "Router",
      funcName: "registerRoute",
      paramName: "route"
    }), d.isType(e.handler, "object", {
      moduleName: "workbox-routing",
      className: "Router",
      funcName: "registerRoute",
      paramName: "route"
    }), d.hasMethod(e.handler, "handle", {
      moduleName: "workbox-routing",
      className: "Router",
      funcName: "registerRoute",
      paramName: "route.handler"
    }), d.isType(e.method, "string", {
      moduleName: "workbox-routing",
      className: "Router",
      funcName: "registerRoute",
      paramName: "route.method"
    })), this._routes.has(e.method) || this._routes.set(e.method, []), this._routes.get(e.method).push(e);
  }
  unregisterRoute(e) {
    if (!this._routes.has(e.method))
      throw new u("unregister-route-but-not-found-with-method", {
        method: e.method
      });
    const s = this._routes.get(e.method).indexOf(e);
    if (s > -1)
      this._routes.get(e.method).splice(s, 1);
    else
      throw new u("unregister-route-route-not-registered");
  }
}
let b;
const ge = () => (b || (b = new fe(), b.addFetchListener(), b.addCacheListener()), b);
function me(t, e, s) {
  let r;
  if (typeof t == "string") {
    const n = new URL(t, location.href);
    if ("production" !== "production") {
      if (!(t.startsWith("/") || t.startsWith("http")))
        throw new u("invalid-string", {
          moduleName: "workbox-routing",
          funcName: "registerRoute",
          paramName: "capture"
        });
      const c = t.startsWith("http") ? n.pathname : t, l = "[*:?+]";
      new RegExp(`${l}`).exec(c) && i.debug(`The '$capture' parameter contains an Express-style wildcard character (${l}). Strings are now always interpreted as exact matches; use a RegExp for partial or wildcard matches.`);
    }
    const o = ({ url: c }) => ("production" !== "production" && c.pathname === n.pathname && c.origin !== n.origin && i.debug(`${t} only partially matches the cross-origin URL ${c.toString()}. This route will only handle cross-origin requests if they match the entire URL.`), c.href === n.href);
    r = new R(o, e, s);
  } else if (t instanceof RegExp)
    r = new pe(t, e, s);
  else if (typeof t == "function")
    r = new R(t, e, s);
  else if (t instanceof R)
    r = t;
  else
    throw new u("unsupported-route-type", {
      moduleName: "workbox-routing",
      funcName: "registerRoute",
      paramName: "capture"
    });
  return ge().registerRoute(r), r;
}
function we(t, e = []) {
  for (const s of [...t.searchParams.keys()])
    e.some((r) => r.test(s)) && t.searchParams.delete(s);
  return t;
}
function* _e(t, { ignoreURLParametersMatching: e = [/^utm_/, /^fbclid$/], directoryIndex: s = "index.html", cleanURLs: r = !0, urlManipulation: a } = {}) {
  const n = new URL(t, location.href);
  n.hash = "", yield n.href;
  const o = we(n, e);
  if (yield o.href, s && o.pathname.endsWith("/")) {
    const c = new URL(o.href);
    c.pathname += s, yield c.href;
  }
  if (r) {
    const c = new URL(o.href);
    c.pathname += ".html", yield c.href;
  }
  if (a) {
    const c = a({ url: n });
    for (const l of c)
      yield l.href;
  }
}
class ye extends R {
  constructor(e, s) {
    const r = ({ request: a }) => {
      const n = e.getURLsToCacheKeys();
      for (const o of _e(a.url, s)) {
        const c = n.get(o);
        if (c) {
          const l = e.getIntegrityForCacheKey(c);
          return { cacheKey: c, integrity: l };
        }
      }
      "production" !== "production" && i.debug("Precaching did not find a match for " + h(a.url));
    };
    super(r, e.strategy);
  }
}
function ve(t) {
  const e = D(), s = new ye(e, t);
  me(s);
}
function be(t) {
  D().precache(t);
}
function Re(t, e) {
  be(t), ve(e);
}
let Ee = [
  ...K,
  ...V.filter((t) => !/(?:\.DS_Store|\.nojekyll)$/.test(t)),
  ...A
].map((t) => ({ url: t, revision: j }));
Re(Ee);
self.addEventListener("message", (t) => {
  t.data && t.data.type === "SKIP_WAITING" && self.skipWaiting();
});
